
in vec3 v_normal;
in vec3 v_worldPos;
in vec2 v_texcoord;
in vec2 v_bumpcoord;
in vec3 v_tangent;
out vec4 color;

layout(binding=0) uniform sampler2DArray diffuseTexture;
layout(binding=1) uniform sampler2DArray emissionTexture;
layout(binding=3) uniform sampler2DArray bumpmapTexture;

/// Calculate Normal from Bumpmap texture
void calculateBumpNormal(inout vec3 normal)
{
    //sample bumpmap texture and convert to TBN
    vec4 tmp = texture(bumpmapTexture, vec3(v_bumpcoord, 0.0));
    vec3 v = normalize(vec3((tmp.x * 2) - 1, (tmp.y * 2) - 1, (tmp.z * 2) - 1));

    // Gram-Schmidt calculation for bumpmapping
    vec3 Tangent = normalize(v_tangent - dot(v_tangent, normal) * normal);
    vec3 BiTangent = normalize(cross(normal, Tangent));

    // get n prime for bumpmapping
    normal = v * mat3(Tangent.x, BiTangent.x, normal.x,     //Col 0
                     Tangent.y, BiTangent.y, normal.y,      //Col 1
                     Tangent.z, BiTangent.z, normal.z);     //Col 2

    normal = (normalize(vec4(normal, 0.0)*worldMatrix)).xyz;
}

vec3 lambert(float cos_theta_i, vec3 baseColor)
{
    return max(0.0, cos_theta_i) * baseColor;
}

vec3 phong(float cos_theta_i, vec3 L, vec3 N, vec3 V, float shininess, vec3 baseColor)
{
    if (cos_theta_i <= 0.0) return vec3(0.0);

    vec3 R = reflect(-L, N);
    float dp = max(0.0, dot(V,R));
    return baseColor * pow(dp, shininess);
}

void computeIllumination(vec3 lightPosition, float posOrDir, 
                            vec3 spotDirection, float cosMaxSpotAngle,
                            vec3 lightColor, float cosSpotFadeAngle,
                            vec3 N, vec3 V, float shininess,
                            vec3 baseColor, out vec3 diffuseAmount,
                            out vec3 specularAmount)
{
    vec3 L = lightPosition.xyz - posOrDir * v_worldPos;
    float lightDistance = max(0.0001, length(L));           //prevents division by 0
    L = 1.0 / lightDistance * L;
    float A = 1.0 / (attenuation[0] + lightDistance * (attenuation[1] + lightDistance * attenuation[2]));
    float cos_theta_i = dot(N, L);
    float spotDot = dot(-L, spotDirection);
    float spotF = clamp((spotDot - cosMaxSpotAngle) / (cosSpotFadeAngle - cosMaxSpotAngle), 0.0, 1.0);
    vec3 tmp = spotF * lightColor * A;

    vec3 H = L + V; //Half Vector between L and V

    float outGoingAngle = dot(N, V);    //Angle between N and V
    float inComingAngle = dot(N, L);    //Angle between N and L
    float pho = dot(V, H);              //Angle between V and H
    float phi = dot(H, N);              //Angle between H and N

    diffuseAmount = tmp * lambert(cos_theta_i, baseColor);
    specularAmount = tmp * phong(cos_theta_i, L, N, V, shininess, baseColor);
}

void computeTotalIllumination(vec3 V, vec3 N, float shininess, vec3 baseColor, out vec3 totalDiffuseAmount, out vec3 totalSpecularAmount)
{
    totalDiffuseAmount = vec3(0);
    totalSpecularAmount = vec3(0);

    for(int i = 0; i < NUM_LIGHTS; i++)
    {
        vec3 diff, spec;
        computeIllumination(lightPositions[i].xyz, lightPositions[i].w,
                            spotlightDirections[i].xyz, spotlightDirections[i].w,
                            lightColors[i].xyz, lightColors[i].w,
                            N, V, shininess,
                            baseColor, diff, spec);
        totalDiffuseAmount += diff;
        totalSpecularAmount += spec;
    }
}

void main(){
    vec3 N = normalize(v_normal);
    calculateBumpNormal(N);

    vec3 V = normalize(eyePos - v_worldPos);

    vec3 totalDiffuseColor = vec3(0);
    vec3 totalSpecularColor = vec3(0);
    float shininess = 2;
    float ambient = 0.1;

    vec4 diffuseTextureColor = texture( diffuseTexture, vec3(v_texcoord,sliceNumber) );
    vec4 emissionTextureColor = texture( emissionTexture, vec3(v_texcoord,sliceNumber) );

    computeTotalIllumination(V, N, shininess, diffuseTextureColor.rgb, totalDiffuseColor, totalSpecularColor);

    color.rgb = ambient * diffuseTextureColor.rgb +
              totalDiffuseColor * diffuseTextureColor.rgb  + 
              totalSpecularColor * diffuseTextureColor.rgb +	//optional: multiply specular by texColor
              emissionTextureColor.rgb;
              
    color.a = diffuseTextureColor.a;
}
