
in vec3 v_normal;
in vec3 v_worldPos;
in vec2 v_texcoord;
in vec2 v_bumpcoord;
in vec3 v_tangent;
out vec4 color;

layout(binding=0) uniform sampler2DArray diffuseTexture;
layout(binding=1) uniform sampler2DArray emissionTexture;
layout(binding=3) uniform sampler2DArray bumpmapTexture;

void main(){
    
    
    vec3 N = normalize(v_normal);
    vec3 V = normalize(eyePos - v_worldPos);

    //sample bumpmap texture and convert to TBN
    vec4 tmp = texture(bumpmapTexture, vec3(v_bumpcoord, 0.0));
    vec3 v = vec3((tmp.x * 2) - 1, (tmp.y * 2) - 1, (tmp.z * 2) - 1);

    // Gram-Schmidt calculation for bumpmapping
    vec3 Tangent = normalize(v_tangent - dot(v_tangent, N)*N);
    vec3 BiTangent = normalize(cross(N, Tangent));

    // get n prime for bumpmapping
    N = v * mat3(Tangent.x, BiTangent.x, N.x,     //Col 0
                 Tangent.y, BiTangent.y, N.y,     //Col 1
                 Tangent.z, BiTangent.z, N.z);    //Col 2

    N = (vec4(N, 0.0)*worldMatrix).xyz;

    vec3 totalDiffuseColor=vec3(0.0);
    vec3 totalSpecularColor=vec3(0.0);
    for(int i=0;i<NUM_LIGHTS;++i){
        float positionalOrDirectional = lightPositions[i].w;
        vec3 lightPos = lightPositions[i].xyz;
        vec3 spotDir = spotlightDirections[i].xyz;
        float cosineMaxSpotAngle = spotlightDirections[i].w;
        vec3 lightColor = lightColors[i].xyz;
        float cosineSpotFadeAngle = lightColors[i].w;	
        vec3 L = lightPos - positionalOrDirectional * v_worldPos;
        float lightDistance = length(L);
        L = 1.0/lightDistance * L;


        float diffusePct = max( 0.0, dot(L,N) );
        
        float specPct = 0.0;
        if( diffusePct > 0.0 ){
            vec3 R = reflect(-L,N);
            specPct = max(0.0, dot(V,R) );
            specPct = pow( specPct, 64.0 );
        }
        
        float spotDot = dot(-L, spotDir );
        float spotF = clamp( (spotDot - cosineMaxSpotAngle) / (cosineSpotFadeAngle - cosineMaxSpotAngle), 0.0, 1.0 );
        
        diffusePct *= spotF;
        specPct *= spotF;
    
        if( positionalOrDirectional == 1.0 ){
            float att = 1.0 / (attenuation[0] + lightDistance*(attenuation[1] + lightDistance*attenuation[2]));
            att = clamp(att, 0.0, 1.0 );
            diffusePct *= att;
            specPct *= att;
        }
        
        totalDiffuseColor += diffusePct * lightColor;
        totalSpecularColor += specPct * lightColor;
        
    }

    vec4 diffuseTextureColor = texture( diffuseTexture, vec3(v_texcoord,sliceNumber) );
    vec4 emissionTextureColor = texture( emissionTexture, vec3(v_texcoord,sliceNumber) );
    color.rgb = 0.1 * diffuseTextureColor.rgb +
              totalDiffuseColor * diffuseTextureColor.rgb  + 
              totalSpecularColor * diffuseTextureColor.rgb +	//optional: multiply specular by texColor
              emissionTextureColor.rgb;
              
    color.a = diffuseTextureColor.a;
}
