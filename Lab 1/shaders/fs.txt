#define PI 3.1415926535897932384626433832795

in vec3 v_normal;
in vec3 v_worldPos;
in vec2 v_texcoord;
in vec2 v_bumpcoord;
in vec3 v_tangent;
out vec4 color;

layout(binding=0) uniform sampler2DArray diffuseTexture;
layout(binding=1) uniform sampler2DArray emissionTexture;
layout(binding=3) uniform sampler2DArray bumpmapTexture;

/////////////////////////////////////////////////////////////////////////////////////////////////////// Normal from Bumpmap texture Calculation
void calculateBumpNormal(inout vec3 normal)
{
    //sample bumpmap texture and convert to TBN
    vec4 tmp = texture(bumpmapTexture, vec3(v_bumpcoord, 0.0));
    vec3 v = normalize(vec3((tmp.x * 2) - 1, (tmp.y * 2) - 1, (tmp.z * 2) - 1));

    // Gram-Schmidt calculation for bumpmapping
    vec3 Tangent = normalize(v_tangent - dot(v_tangent, normal) * normal);
    vec3 BiTangent = normalize(cross(normal, Tangent));

    // get n prime for bumpmapping
    normal = v * mat3(Tangent.x, BiTangent.x, normal.x,     //Col 0
                     Tangent.y, BiTangent.y, normal.y,      //Col 1
                     Tangent.z, BiTangent.z, normal.z);     //Col 2

    normal = (normalize(vec4(normal, 0.0)*worldMatrix)).xyz;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////// Diffuse Calculations
vec3 lambert(float cos_theta_i, vec3 baseColor)
{
    return max(0.0, cos_theta_i) * baseColor;
}

//F = schlickFresnel();
vec3 schlickDiffuse(vec3 F, float cos_phi, float metallicity, vec3 baseColor, float cos_theta_i)
{
    vec3 d = mix(0.96 * baseColor, vec3(0), metallicity);
    return cos_theta_i * (vec3(1.0)-F) * d / PI;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////// Specular Calculations
// Base Phong Specular Calculation
vec3 phong(float cos_theta_i, vec3 L, vec3 N, vec3 V, float shininess, vec3 baseColor)
{
    if (cos_theta_i <= 0.0) return vec3(0.0);

    vec3 R = reflect(-L, N);
    float dp = max(0.0, dot(V,R));
    return baseColor * pow(dp, shininess);
}

// Luna Specular Calculation
// Uses Fresnel Calculation for small scale roughness of materials at angle based on microfacets
vec3 lunaFresnel(float cos_phi, vec3 F0)
{
    vec3 one_minus_F0 = vec3(1.0) - F0;
    return F0 + one_minus_F0 * pow(1.0 - cos_phi, 5.0);
}

vec3 luna(float cos_psi, float cos_phi, vec3 baseColor, float shininess)
{
    vec3 F = lunaFresnel(cos_phi, baseColor);
    return F * (shininess + 8.0)/8.0 * pow(cos_psi, shininess);
}

// Schlick Specular Calculation
// Uses Fresnel Calculation, Visibility Factor, and Microfacet Distribution
vec3 schlickFresnel(float cos_phi, vec3 baseColor, float metallicity)
{
    vec3 F0 = mix(vec3(0.04), baseColor, metallicity);
    vec3 one_minus_F0 = vec3(1.0) - F0;
    return F0 + one_minus_F0 * pow(1 - cos_phi, 5.0);
}

vec3 schlickSpecular(vec3 F, float cos_phi, float cos_psi,
                    vec3 baseColor, float cos_theta_i,
                    float cos_theta_o, float rho, float mu)
{
    float rho2 = rho*rho;
    float V = 1.0 / (
            2.0 * (cos_theta_i * sqrt(rho2 + (1.0 - rho2) * cos_theta_o * cos_theta_o) + 
            cos_theta_o * sqrt(rho2 + (1.0 - rho2) * cos_theta_i * cos_theta_i)));
    float tmp = rho / (1.0 + cos_psi * cos_psi * (rho2 - 1.0));
    float D = 1.0 / PI * tmp * tmp;
    return cos_theta_i * F * V * D;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////// Lighting and Color Calculations
void computeIllumination(vec3 lightPosition, float posOrDir, 
                            vec3 spotDirection, float cosMaxSpotAngle,
                            vec3 lightColor, float cosSpotFadeAngle,
                            vec3 N, vec3 V, float shininess,
                            vec3 baseColor, out vec3 diffuseAmount,
                            out vec3 specularAmount)
{
    // Lighting
    vec3 L = lightPosition.xyz - posOrDir * v_worldPos;
    float lightDistance = max(0.0001, length(L));           //prevents division by 0
    L = 1.0 / lightDistance * L;
    float A = 1.0 / (attenuation[0] + lightDistance * (attenuation[1] + lightDistance * attenuation[2]));
    float cos_theta_i = dot(N, L);
    float spotDot = dot(-L, spotDirection);
    float spotF = clamp((spotDot - cosMaxSpotAngle) / (cosSpotFadeAngle - cosMaxSpotAngle), 0.0, 1.0);
    vec3 tmp = spotF * lightColor * A;

    vec3 H = L + V; //Half Vector between L and V

    // Constants
    float metallicity = 2;
    float rho = .5;

    // Angles CHECK THESE!!!!!
    float cos_out = dot(N, V);              //Angle between N and V
    float sin_out = sqrt(1-pow(cos_out,2));

    float cos_in = dot(N, L);               //Angle between N and L
    float sin_in = sqrt(1-pow(cos_in,2));

    float cos_phi = dot(V, H);              //Angle between V and H
    float cos_psi = dot(H, N);              //Angle between H and N

    //schlick Computations
    //vec3 F = schlickFresnel(cos_phi, baseColor, metallicity);
    //diffuseAmount = tmp * schlickDiffuse(F, cos_phi, metallicity, baseColor, cos_in);
    //specularAmount = tmp * schlickSpecular(F, cos_phi, cos_psi, baseColor, cos_in, cos_out, rho, metallicity);

    //Basic Phon and lambert
    diffuseAmount = tmp * lambert(cos_theta_i, baseColor);
    specularAmount = tmp * phong(cos_theta_i, L, N, V, shininess, baseColor);
    
    //luna Computations
    //specularAmount = tmp * luna(cos_psi, cos_phi, baseColor, shininess);
}

void computeTotalIllumination(vec3 V, vec3 N, float shininess, vec3 baseColor, out vec3 totalDiffuseAmount, out vec3 totalSpecularAmount)
{
    totalDiffuseAmount = vec3(0);
    totalSpecularAmount = vec3(0);

    for(int i = 0; i < NUM_LIGHTS; i++)
    {
        vec3 diff, spec;
        computeIllumination(lightPositions[i].xyz, lightPositions[i].w,
                            spotlightDirections[i].xyz, spotlightDirections[i].w,
                            lightColors[i].xyz, lightColors[i].w,
                            N, V, shininess,
                            baseColor, diff, spec);
        totalDiffuseAmount += diff;
        totalSpecularAmount += spec;
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////// Main
void main(){
    vec3 N = normalize(v_normal);
    calculateBumpNormal(N);

    vec3 V = normalize(eyePos - v_worldPos);

    vec3 totalDiffuseColor = vec3(0);
    vec3 totalSpecularColor = vec3(0);

    vec4 diffuseTextureColor = texture( diffuseTexture, vec3(v_texcoord,sliceNumber) );
    vec4 emissionTextureColor = texture( emissionTexture, vec3(v_texcoord,sliceNumber) );

    float shininess = 2.0;
    float ambientColor = .1;
    float metallicity = 2;

    computeTotalIllumination(V, N, shininess, diffuseTextureColor.rgb, totalDiffuseColor, totalSpecularColor);


    color.rgb = ambientColor * diffuseTextureColor.rgb +
              totalDiffuseColor * diffuseTextureColor.rgb  + 
              totalSpecularColor * diffuseTextureColor.rgb +	//optional: multiply specular by texColor
              emissionTextureColor.rgb;
    
    /*
    color.rgb = ambientColor * diffuseTextureColor.rgb +
              totalDiffuseColor  + 
              totalSpecularColor +	//optional: multiply specular by texColor
              emissionTextureColor.rgb;
    */

    color.a = diffuseTextureColor.a;
}
